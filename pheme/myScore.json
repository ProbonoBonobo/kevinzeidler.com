["Basic semaphore operations.","$pheme = new Semaphore('pheme');",[["null","Sanity check: True assertions pass (should PASS)","true","1",true,"PASS"],["null","Sanity check: False assertions fail (should FAIL)","false","1",false,"FAIL"],["0","Create a semaphore.","isset($pheme)","1",true,"PASS"],["1","A semaphore has 3 memory registers.","$pheme->get('regA') && $pheme->get('regB') && $pheme->get('regC')","1",true,"PASS"],["2","The first register is always a string.","is_string($pheme->get('regA'))","1",true,"PASS"],["3","Always. Even when the register is empty.","$pheme->get('regA')","'theEmptyString'","theEmptyString","PASS"],["4","If the register contains 'theEmptyString', then it's empty.","$pheme->isEmpty('regA')","true",1,"PASS"],["5","The second register is a string *only* when it is empty.","$pheme->get('regB')","'theEmptyList'","theEmptyList","PASS"],["6","This is also presumed to be true for the third register.","$pheme->get('regC')","'theEmptyList'","theEmptyList","PASS"],["7","Semaphores therefore must implement the idea of 'emptiness' differently from the underlying PHP.","$pheme->isEmpty('regB')","true",1,"PASS"],["8","This should never be true.","empty($pheme->get('regB'))","false",false,"PASS"],["9","Empty semaphores are identified by a status code of 0.","statusCode($pheme)","0",0,"PASS"],["10","There is an alternate view mode that will come in handy later.","bin($pheme)","0","0","PASS"],["11","The target register is initially set to regA.","$pheme->get('currentTargetName')","'regA'","regA","PASS"],["12","Let's add something to the semaphore.","$pheme->push('add')","$pheme",null,"N\/A"],["13","Semaphore pushes the value to the target register.","$pheme->get('regA')","'add'","theEmptyString","FAIL"],["13","Current target should still be regA.","$pheme->get('currentTargetName')","'regA'","regA","PASS"],["14","Add something else to it.","$pheme->push('subtract')","$pheme",null,"N\/A"],["13","Target remains the same.","$pheme->get('currentTargetName')","'regA'","regA","PASS"],["15","The value of regA is now 'subtract'.'","$pheme->get('regA')","'subtract'","theEmptyString","FAIL"],["16","Why? Notice the semaphore is red. It flipped its color when we added something to it.","$pheme->get('color')","'red'","red","PASS"],["16","It also has a cool new status code.","statusCode($pheme)","2",0,"FAIL"],["16","The binary view is more informative though","bin($pheme)","10","0","FAIL"],["17","A red semaphore must be flushed or locked before proceeding. Try locking it.","$pheme->lock()","$pheme",null,"N\/A"],["18","Successful lock operations always add 1 to the current status code.","statusCode($pheme)","3",1,"FAIL"],["18","And the new binary representation thus becomes...","bin($pheme)","11","1","FAIL"],["19","Lock operations also flip the color. ","$pheme->get('color')","'green'","red","FAIL"],["20","We may now resume adding stuff to the semaphore.","$pheme->push('5')","$pheme",null,"N\/A"],["21","regB is an array, so we can push multiple values to it. Push another number.","$pheme->push('3289')","$pheme",null,"N\/A"],["19","Its color should remain green","$pheme->get('color')","'green'","red","FAIL"],["21","Status code is different though.","statusCode($pheme)","6",1,"FAIL"],["21","The decimal statusCode is derived from binary, which is derived from which of its registers have something inside. The rightmost bit corresponds to the lock bit, so it's zero.","bin($pheme)","110","1","FAIL"],["21","Try locking it.","$pheme->lock()","$pheme",null,"N\/A"],["21","regB should be an array of 2 numbers","is_array($pheme->get('regB'))","true",false,"FAIL"],["21","Now push!","$pheme->push('equals')","$pheme",null,"N\/A"]]]